/*
	Uvod u relacione baze podataka - cas 9
	Pogledi (VIEW). Indeksi (INDEX). 
	Korisnicki definisane funkcije.
*/

/*
    ** POGLEDI **
	
	Pogledati (dodatno): MATERIALIZED VIEW
	
	Sintaksa:
		CREATE VIEW IME_POGLEDA AS
		SELECT ...
		FROM ...
		WHERE ...
		[WITH CHECK OPTION];
		
		DROP VIEW IME_POGLEDA;
		
	Moze se razumeti kao upit sacuvan u promenljivu.
	Pogled se koristi kao tabela. Svaki put kad se 
	vrsi upit nad pogledom, ponovo se pokrece upit pogleda.
	
	Ukoliko je u pogled definisan samo nad jednom tabelom,
	originalna tabela moze da se menja preko tog pogled.
	Ovde je korisno koristiti podupite kao zamenu za spajanje.
	Ukoliko kolona nije navedena u pogledu, pri unosu njena
	vrednost bice NULL (zbog toga se u ovakvim pogledima 
	moraju navesti sve NOT NULL kolone).
	
	TABELA:
	|   A   |   B   |   C   |   D   |
	-------------------------------
	    rA     NULL     rC     NULL
	
	POGLED:
	|   A   |   C   |
	-----------------
	   rA      rC
	
	WITH CHECK OPTION navodimo ukoliko zelimo da se pri unosu
	proverava da li dati red zadovoljava uslov pogleda
	(bez WITH CHECK OPTION u tabelu mozemo preko pogleda
	dodati i red koji ne zadovoljava uslov pogleda). Sto se tice
	menjanja i brisanja redova preko pogleda, tu se mogu menjati
	i brisati samo oni redovi koji se vide u pogledu (tj. koji
	zadovoljavaju uslov pogleda).
*/

/*
	** INDEKSI **
	
	Sintaksa:
		CREATE INDEX NAZIV_INDEKSA
		ON NAZIV_TABELE
			(KOL1 [ASC|DESC], KOL2 [ASC|DESC], ...);
			
		DROP INDEX NAZIV_INDEKSA;
		
	Indeksi se koriste kao dodatna struktura kojom se tabela
	sortira na odredjeni nacin. Moze postojati vise indeksa
	odnosno vise sortiranja odredjene tabele. Ukoliko izvrsavamo
	upit, pri cemu restrikciju vrsimo iskljucivo po kolonoma nad 
	kojima je definisan neki indeks, pretraga ce se vrsiti nad tim 
	indeksom (u logaritamskoj slozenosti, binarnom pretragom). 
	Vise o indeksima na predavanjima!
	
	CREATE INDEX IND
	ON TAB
		(KOL1, KOL2, KOL3);
		
	|  KOL1  |  KOL 2  |  KOL3  |
	-----------------------------
		1         a			1
		1         a         2
		1         b
		1         c
		2         a
		2         b
		2         c
		3
		4
		5
		5
		

*/

/*
	** FUNKCIJE **
	
	Sintaksa:
		CREATE FUNCTION IME_FUNKCIJE (ARG1 TYPE1, ARG2 TYPE2,...)
		RETURNS RETURN_TYPE
		RETURN BODY;
		
		DROP FUNCTION IME_FUNKCIJE;

*/

-- 1. Napraviti tabelu TEST sa kolonama ID (ceo broj, primarni ključ) i 
-- SLOVO (karakter). Obezbediti da se vrednost ID automatski generiše 
-- ukoliko nije navedena. Zatim izvršavati stavke po redu:
-- 	- U datu tabelu uneti vrednost SLOVO='a'
-- 	- U datu tabelu uneti vrednost ID=2, SLOVO='b'
-- 	- U datu tabelu uneti vrednost SLOVO='c'

DROP TABLE IF EXISTS DA.TEST;

CREATE TABLE /* IF NOT EXISTS */ DA.TEST (
	ID		INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY
								(START WITH 100, INCREMENT BY 2),
	SLOVO	CHAR,
	PRIMARY KEY (ID)
);

SELECT * FROM DA.TEST;

INSERT INTO DA.TEST (SLOVO) VALUES ('a');
INSERT INTO DA.TEST VALUES (2, 'b');
INSERT INTO DA.TEST (SLOVO) VALUES ('c');

SELECT * FROM DA.TEST;

-- 2. Za svakog studenta smera Informatika na osnovnim akademskim studijama,
-- koji je fakultet upisao 2015. godine, pronaći koje obavezne predmete nije 
-- položio. Izdvojiti ime i prezime studenta i naziv predmeta.

WITH OAS_INFORMATIKA AS (
	SELECT SP.ID IDPROGRAMA
	FROM DA.STUDIJSKIPROGRAM SP JOIN DA.NIVOKVALIFIKACIJE NK
						ON (SP.IDNIVOA = NK.ID)
	WHERE SP.NAZIV = 'Informatika' AND NK.NAZIV = 'Osnovne akademske studije'
),
STUDENTI_INF_OAS AS (
	SELECT INDEKS, IME, PREZIME
	FROM DA.DOSIJE
	WHERE IDPROGRAMA = (SELECT IDPROGRAMA FROM OAS_INFORMATIKA)
	AND YEAR(DATUPISA) = 2015
),
OBAVEZNI_INF_OAS AS (
	SELECT P.NAZIV, P.ID IDPREDMETA
	FROM DA.PREDMETPROGRAMA PP JOIN DA.PREDMET P ON (PP.IDPREDMETA = P.ID)
	WHERE PP.VRSTA = 'obavezan'
		 AND PP.IDPROGRAMA = (SELECT IDPROGRAMA FROM OAS_INFORMATIKA)
)
SELECT SIO.IME, SIO.PREZIME, OIO.NAZIV 
FROM STUDENTI_INF_OAS SIO JOIN OBAVEZNI_INF_OAS OIO
ON (NOT EXISTS (
	SELECT *
	FROM DA.ISPIT I
	WHERE SIO.INDEKS = I.INDEKS
		AND OIO.IDPREDMETA = I.IDPREDMETA
		AND I.OCENA > 5 AND I.STATUS = 'o'
));

-- 3. Napraviti pogled kojim se izdvajaju svi ispitni rokovi održani 
-- od 2018/2019. školske godine. A zatim odraditi sledeće:
-- 	- Uneti ispitni rok jan1 2022. godine u pogled.
--	- Uneti u tabelu ispitnirok rok jan2 2022
-- 	- U pogled uneti rok sa oznakom 'xxx' održan 2015-e godine.
--	- Promeni oznaku roka xxx 2015 u kreiranom pogledu u 'test'.
--	- Obrisati rok sa oznakom 'xxx' iz pogleda.
--	- Obrisati ispitne rokove održane 2022 iz pogleda.
--	- Obrisati pogled.

CREATE VIEW ROKOVI AS 
SELECT *
FROM DA.ISPITNIROK
WHERE SKGODINA >= 2018;

SELECT * FROM ROKOVI; 

INSERT INTO DA.SKOLSKAGODINA VALUES 
		(2021, '01.10.2021', '30.09.2022');
INSERT INTO ROKOVI VALUES (2021, 'jan1', 'Januar1 2022',
								'01.01.2022', '30.01.2022');
								
SELECT * FROM DA.ISPITNIROK WHERE SKGODINA = 2021;

INSERT INTO DA.ISPITNIROK VALUES (2021, 'jan2', 'Januar2 2022',
									'01.02.2022', '28.02.2022');
									
INSERT INTO ROKOVI VALUES (2015, 'xxx', 'XXX',
							'01.04.2015', '15.04.2015');

SELECT * FROM ROKOVI;
SELECT * FROM DA.ISPITNIROK;

UPDATE ROKOVI 
SET OZNAKAROKA = 'test' 
WHERE SKGODINA = 2015 AND OZNAKAROKA = 'xxx';

DELETE FROM ROKOVI
WHERE OZNAKAROKA = 'xxx';

DELETE FROM ROKOVI
WHERE SKGODINA = 2021;

DROP VIEW ROKOVI;

-- 4. Napraviti pogled sa svim prijavljenim ispitima Marka Petrovića. 
-- A zatim svim ispitima iz pogleda staviti datum polaganja na null.

CREATE VIEW ISPIT_MARKO AS
SELECT *
FROM DA.ISPIT  
WHERE INDEKS = (
	SELECT INDEKS 
	FROM DA.DOSIJE
	WHERE IME = 'Marko'
		AND PREZIME = 'Petrovic'
);

SELECT * FROM ISPIT_MARKO;

UPDATE ISPIT_MARKO
SET DATPOLAGANJA = NULL;

SELECT * FROM ISPIT_MARKO;
SELECT * FROM DA.ISPIT WHERE INDEKS = 20190280;

DROP VIEW ISPIT_MARKO;

-- 5. Napraviti pogled kojim se izdvajaju svi prijavljeni ispiti 
-- studenata koji se zovu Marko ili Marija, a u ispitnom roku jan1 
-- 2018/2019. šk. godine su položili barem jedan ispit. Pogled 
-- napisati tako da je kroz njega moguće dodavanje novih ispita koji 
-- zadovoljavaju uslove pogleda. Pokušati dodati sledeća dva reda:
-- 	- Marko: indeks 20150013, idpredmeta 2027, skgodina 2018, 
--    oznakaroka sep2, status o, 40 poena, ocena 5
-- 	- Jovana: indeks 20150001, idpredmeta 2027, skgodina 2018, 
--    oznakaroka sep2, status o, 40 poena, ocena 5.
-- Ukoliko neko ubacivanje ne uspe pokušati uneti red direktno u 
-- tabelu ispit. Za dva uneta reda pokušati izmenu datuma polaganja 
-- nad pogledom na današnji datum. Ukoliko izmena nad pogledom ne 
-- uspe odraditi je direktno na tabeli. Na kraju pokuati brisanje 
-- ova dva reda preko pogleda.

CREATE VIEW POGLED AS
SELECT *
FROM DA.ISPIT I
WHERE I.INDEKS IN (
	SELECT D.INDEKS
	FROM DA.DOSIJE D
	WHERE D.IME IN ('Marko', 'Marija')
) AND EXISTS (
	SELECT *
	FROM DA.ISPIT I1
	WHERE I.INDEKS = I1.INDEKS
	AND I1.OCENA > 5 AND I1.STATUS = 'o'
	AND I1.SKGODINA = 2018 AND I1.OZNAKAROKA = 'jan1'
)
WITH CHECK OPTION;

SELECT * FROM POGLED;

-- 	- Marko: indeks 20150013, idpredmeta 2027, skgodina 2018, 
--    oznakaroka sep2, status o, 40 poena, ocena 5
-- 	- Jovana: indeks 20150001, idpredmeta 2027, skgodina 2018, 
--    oznakaroka sep2, status o, 40 poena, ocena 5.

INSERT INTO POGLED (INDEKS, SKGODINA, OZNAKAROKA,
				IDPREDMETA, STATUS, POENI, OCENA) VALUES
				(20150013, 2018, 'sep2',
				2027, 'o', 40, 5);
				
INSERT INTO POGLED (INDEKS, SKGODINA, OZNAKAROKA,
				IDPREDMETA, STATUS, POENI, OCENA) VALUES
				(20150001, 2018, 'sep2',
				2027, 'o', 40, 5);	
					
INSERT INTO DA.KURS VALUES (2018, 2, 2027);
INSERT INTO DA.UPISANKURS VALUES (20150001, 2018, 2, 2027);
INSERT INTO DA.ISPIT (INDEKS, SKGODINA, OZNAKAROKA,
				IDPREDMETA, STATUS, POENI, OCENA) VALUES
				(20150001, 2018, 'sep2',
				2027, 'o', 40, 5);

SELECT * FROM DA.ISPIT WHERE INDEKS = 20150001 AND SKGODINA = 2018;


UPDATE POGLED
SET DATPOLAGANJA = CURRENT_DATE
WHERE INDEKS = 20150013
		AND SKGODINA = 2018
		AND OZNAKAROKA = 'sep2'
		AND IDPREDMETA = 2027;
				
UPDATE POGLED
SET DATPOLAGANJA = CURRENT_DATE
WHERE INDEKS = 20150001
		AND SKGODINA = 2018
		AND OZNAKAROKA = 'sep2'
		AND IDPREDMETA = 2027;
		
UPDATE DA.ISPIT
SET DATPOLAGANJA = CURRENT_DATE
WHERE INDEKS = 20150001
		AND SKGODINA = 2018
		AND OZNAKAROKA = 'sep2'
		AND IDPREDMETA = 2027;
		
DELETE FROM POGLED
WHERE INDEKS = 20150013
		AND SKGODINA = 2018
		AND OZNAKAROKA = 'sep2'
		AND IDPREDMETA = 2027;

SELECT * FROM POGLED WHERE INDEKS = 20150013 AND SKGODINA = 2018;

DELETE FROM POGLED
WHERE INDEKS = 20150001
		AND SKGODINA = 2018
		AND OZNAKAROKA = 'sep2'
		AND IDPREDMETA = 2027;
		
DELETE FROM DA.ISPIT
WHERE INDEKS = 20150001
		AND SKGODINA = 2018
		AND OZNAKAROKA = 'sep2'
		AND IDPREDMETA = 2027;
		
-- 6. Napraviti indeks tabele dosije po imenu i prezimenu u 
-- opadajućem redosledu. Zatim ga obrisati.

CREATE INDEX DA.IND_DOSIJE_IME_PREZIME
ON DA.DOSIJE (PREZIME DESC, IME DESC);

SELECT * FROM DA.DOSIJE ORDER BY PREZIME DESC, IME DESC;

DROP INDEX DA.IND_DOSIJE_IME_PREZIME;

-- 7. Napisati korisnički definisanu funkciju koja vraća cenu 
-- predmeta za samofinansirajuće studente. Kao argument se zadaje 
-- broj espb. Cena jednog espb boda je 2000 dinara.

DROP FUNCTION ESPB;

CREATE FUNCTION ESPB (BROJ_ESPB INTEGER)
RETURNS FLOAT
RETURN 2000.0 * BROJ_ESPB;

VALUES (ESPB(20));

-- 8. Napisati korisnički definisanu funkciju koja vraća cenu 
-- predmeta za samofinansirajuće studente. Kao argument se 
-- zadaje id predmeta. Cena jednog espb boda je 2000 dinara.

CREATE FUNCTION ESPB_PR (IDPREDMETA INTEGER)
RETURNS FLOAT
RETURN 
SELECT 2000.0 * ESPB
FROM DA.PREDMET
WHERE ID = IDPREDMETA;

VALUES (ESPB_PR(2027));

SELECT * FROM DA.PREDMET WHERE ID = 2027;

-- 9. Napisati korisnički definisnu funkciju koja vraća prosek 
-- studenta sa zadatim indekom. Zaokružiti prosek na dve decimale.

CREATE FUNCTION PROSEK (INDEKS INTEGER)
RETURNS FLOAT
RETURN 
SELECT ROUND(AVG(I.OCENA*1.0), 2)
FROM DA.ISPIT I
WHERE I.INDEKS = INDEKS
AND I.OCENA > 5 AND I.STATUS = 'o';

VALUES (PROSEK(20150001));

-- 10. Napisati korisnički definisanu funkciju koja vraća koji je
-- danas dan. Vraća naziv dana u nedelju ukoliko je radni dan, 
-- inače vraća 'WEEKEND'.

CREATE FUNCTION DAN (DANAS DATE)
RETURNS VARCHAR(20)
RETURN
CASE
	WHEN DAYOFWEEK(DANAS) IN (1, 7) THEN 'WEEKEND'
	ELSE DAYNAME(DANAS)
END;

VALUES (DAN(CURRENT_DATE));
VALUES (DAN(CURRENT_DATE + 2 DAYS));



